#include <stdio.h>        //Πηγαίος Κώδικας
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <errno.h>

typedef struct                //Δημιοθργία δομής struct για τα προϊόντα
{
    char description[100];    //Περιγραφή προϊόντος
    double price;             //Τιμή προϊόντος
    int item_count;           //Διαθεσιμότητα προϊόντος
    int aithmata;             //Αιτήματα αγοράς από τους πελάτες
    int temaxia_sell;         //Τεμάχια του προϊόντος που πωλήθηκαν 
} product;

void init_catalog(product catalog[])    //Συνάρτηση για την Αρχικοποίηση του πίνακα catalog
{
    for(int i=0; i<20; i++)          //Επανάληψη 20 φορές για τα 20 προϊόντα
    {
        sprintf(catalog[i].description, "Product(%d)", i+1);   //Αρχικοποίηση της περιγραφής του προϊόντος με χρήση sprintf ώστε να περάσει η τιμή  του i+1 στο "Product(%d)"
        catalog[i].price = i*3;                  //Αρχικοποίηση της τιμής του προϊόντος με την τιμή του i*3 ώστε να έχουμε διαφορετικές τιμές για κάθε προϊόν
        catalog[i].item_count = 2;               //Αρχικοποίηση της διαθεσιμότητας του προϊόντος με 2
        catalog[i].aithmata = 0;                 //Αρχικοποίηση των αιτημάτων αγοράς του προϊόντος με 0
        catalog[i].temaxia_sell = 0;             //Αρχικοποίηση των τεμαχίων που πωλήθηκαν με 0
    }
}

//Δημιουργία συναρτήσεων για την εκτέλεση των διεργασιών

//Συνάρτηση για την διαχείρηση των υποβληθέντων παραγγελιών από τους πελάτες
void parent_orders(product catalog[], int p1[2], int p2[2], int *sum_parag, int *sum_succparag, int *sum_failparag, double *sum_price)
{                                                           //Χρήση δεικτών για την μεταφορά των τιμών των μεταβλητών για χρήση τους στην main συνάρτηση
    int i;
                                //Κλείσιμο των ακρών των διοχετεύσεων που δεν χρησιμοποιούνται
   close(p1[0]);                //Κλείσιμο άκρου του αναγνώστη (read) της πρώτης διοχέτευσης
   close(p2[1]);                //Κλείσιμο άκρου του συγγραφέα (write) της δεύτερης διοχέτευσης

   for(i=0; i<50; i++)          //Επανάληψη 50 φορές για τις 50 παραγγελίες
   { 
        char buff[100];         //Δήλωση πίνακα χαρακτήρων 100 θέσεων για την αποθήκευση του μηνύματος για το αποτέλεσμα της παραγγελίας που θα σταλεί στον πελάτη
        int arithmos_prod;      //Δήλωση μεταβλητής ακεραίου για την αποθήκευση του αριθμού του προϊόντος που επέλεξε ο πελάτης

        read(p2[0], &arithmos_prod, sizeof(arithmos_prod));       //Ανάγνωση του αριθμού του προϊόντος που επέλεξε ο πελάτης από τον αναγνώστη (read) της δεύτερης διοχέτευσης
        (*sum_parag) = (*sum_parag) + 1;                    //Αύξηση κατά 1 του συνολικού αριθμού των παραγγελιών
        catalog[arithmos_prod].aithmata++;                  //Αύξηση κατά 1 των αιτημάτων αγοράς του προϊόντος που επέλεξε ο πελάτης

        if(catalog[arithmos_prod].item_count > 0)           //Έλεγχος για αν το προϊόν είναι διαθέσιμο
        {
            (*sum_succparag) = (*sum_succparag) + 1;        //Αύξηση κατά 1 των επιτυχημένων παραγγελιών
            (*sum_price) = (*sum_price) + catalog[arithmos_prod].price;     //Αύξηση του συνολικού κόστους των παραγγελιών προσθέτοντας την τιμή του προϊόντος
            catalog[arithmos_prod].item_count--;                            //Μείωση της διαθεσιμότητας του προϊόντος κατά 1
            catalog[arithmos_prod].temaxia_sell++;                          //Αύξηση κατά 1 των τεμαχίων που πωλήθηκαν
                
            sprintf(buff, "Purchase complete, your total is %.2lf", catalog[arithmos_prod].price);    //Αποθήκευση του μηνύματος για το αποτέλεσμα της παραγγελίας στον πίνακα buff, χρησιμοποιώντας την sprintf για την εισαγωγή της τιμής του προϊόντος με ακρίβεια 2 δεκαδικών ψηφίων
            write (p1[1], buff, sizeof(buff));                                                        //Αποστολή του μηνύματος στον πελάτη για το αποτέλεσμα της παραγγελίας μέσω του συγγραφέα (write) της πρώτης διοχέτευσης
        }
            
        else  //Περίπτωση που το προϊόν δεν είναι διαθέσιμο
        {   
           (*sum_failparag) = (*sum_failparag) + 1;   //Αύξηση κατά 1 των αποτυχημένων παραγγελιών
           write (p1[1], "Products unavailable, request failed", sizeof("Products unavailable, request failed"));  //Αποστολή μηνύματος στον πελάτη για το αποτέλεσμα της παραγγελίας μέσω του συγγραφέα (write) της πρώτης διοχέτευσης
        }

        sleep(1);   //Χρόνος διεκπεραίωσης της παραγγελίας 1 δευτερόλεπτο 
    }  
                    //Κλείσιμο των ακρών των διοχετεύσεων που χρησιμοποιήθηκαν για αποφυγή διαρροής μνήμης
    close(p1[1]);   //Κλείσιμο του συγγραφέα (write) της πρώτης διοχέτευσης
    close(p2[0]);   //Κλείσιμο του αναγνώστη (read) της δεύτερης διοχέτευσης
}


//Συνάρτηση για την υποβολή αιτημάτων αγοράς προϊόντων από τους πελάτες
void child_orders(int p1[2], int p2[2], int client_arithmos)
{
    int i;
    int arithmos_prod;      //Δήλωση μεταβλητής ακεραίου για την αποθήκευση του αριθμού του προϊόντος που επέλεξε ο πελάτης

                          //Κλείσιμο των ακρών των διοχετεύσεων που δεν χρησιμοποιούνται
    close(p1[1]);         //Κλείσιμο του συγγραφέα (write) της πρώτης διοχέτευσης
    close(p2[0]);         //Κλείσιμο του αναγνώστη (read) της δεύτερης διοχέτευσης

    srand(time(NULL));    

    for(i=0; i<10; i++)         //Επανάληψη 10 φορές για την υποβολή 10 παραγγελιών από τον πελάτη
    {
        arithmos_prod = rand() % 20;   //Παραγωγή τυχαίου αριθμού από το 0 έως το 19 για την επιλογή του προϊόντος που θα αγοράσει ο πελάτης

        write(p2[1], &arithmos_prod, sizeof(arithmos_prod));  //Αποστολή του αριθμού του προϊόντος που επέλεξε ο πελάτης στο κατάστημα μέσω του συγγραφέα (write) της δεύτερης διοχέτευσης για την πραγματοποίηση της παραγγελίας

        char buf[100];                      //Δήλωση πίνακα χαρακτήρων 100 θέσεων για την αποθήκευση του μηνύματος για το αποτέλεσμα της παραγγελίας που στλενεται από το κατάστημα στον πελάτη
        read(p1[0], buf, sizeof(buf));       //Ανάγνωση του μηνύματος για το αποτέλεσμα της παραγγελίας από το κατάστημα μέσω του αναγνώστη (read) της πρώτης διοχέτευσης

        printf("Client %d: %s\n", client_arithmos, buf);   //Εμφάνιση μηνύματος για το αποτέλεσμα της παραγγελίας του πελάτη

        sleep(1);       //Αναμονή 1 δευτερόλεπτο ανάμεσα στις παραγγελίες των πελατών
    }
                     //Κλείσιμο των ακρών των διοχετεύσεων που χρησιμοποιήθηκαν για αποφυγή διαρροής μνήμης
    close(p1[0]);    //Κλείσιμο του αναγνώστη (read) της πρώτης διοχέτευσης
    close(p2[1]);    //Κλείσιμο του συγγραφέα (write) της δεύτερης διοχέτευσης

    exit(0);     //Εξοδος της θυγατρικής διεργασίας
}

//Συνάρτηση για την εξαγωγή συγκεντρωτικής αναφοράς για κάθε προϊόν
void anafora(product catalog[])
{
    int i;

    for(i=0; i<20; i++)   //Επανάληψη 20 φορές για τα 20 προϊόντα
    {
        printf("\nPerigrafi Proiontos %d: %s\n", i+1, catalog[i].description);  //Εμφάνιση της περιγραφής του προϊόντος
        printf("Aithmata gia agora: %d\n", catalog[i].aithmata);                //Εμφάνιση των συνολικών αιτημάτων αγοράς του προϊόντος
        printf("Temaxia Agorastikan: %d\n", catalog[i].temaxia_sell);           //Εμφάνιση του συνολικού αριθμού τεμαχίων που πωλήθηκαν
    }
}

//Συνάρτηση για την τύπωση συγκεντρωτικού μηνύματος με τα στατιστικά των παραγγελιών
void statistics(int sum_parag, int sum_succparag, int sum_failparag, double sum_price)
{
    printf("\nSunolikos arithmos paraggeliwn: %d\n", sum_parag);   //Εμφάνιση του συνολικού αριθμού των παραγγελιών που υποβλήθηκαν
    printf("Epituxhmenes Paraggelies: %d\n", sum_succparag);       //Εμφάνιση του συνολικού αριθμού των επιτυχημένων παραγγελιών που υποβλήθηκαν
    printf("Apotuxhmenes Paraggelies: %d\n", sum_failparag);       //Εμφάνιση του συνολικού αριθμού των αποτυχημένων παραγγελιών που υποβλήθηκαν
    printf("Sunoliko kostos: %.2lf\n", sum_price);                 //Εμφάνιση του συνολικού κόστους των παραγγελιών που υποβλήθηκαν με ακρίβεια 2 δεκαδικά ψηφίά
}

//Συνάρτηση για την εκτέλεση των διεργασιών
int main()
{    
    product catalog[20];    //Δήλωση του πίνακα catalog με 20 θέσεις τύπου δομής struct product για τα προϊόντα 
    init_catalog(catalog);  //Αρχικοποίηση του πίνακα catalog με την χρήση της συνάρτησης init_catalog

    int i;
    int p1[2];      //Πρώτη διοχέτευση για την αποστολή του μηνύματος για το αποτέλεσμα της παραγγελίας στους πελάτες
    int p2[2];      //Δεύτερη διοχέτευση για την αποστολή παραγγελιών από τους πελάτες

    int sum_parag = 0;          //Δήλωση ακεραίου για τον συνολικό αριθμό των παραγγελιών
    int sum_succparag = 0;      //Δήλωση ακεραίου για τον συνολικό αριθμό των επιτυχημένων παραγγελιών
    int sum_failparag = 0;      //Δήλωση ακεραίου για τον συνολικό αριθμό των αποτυχημένων παραγγελιών
    double sum_price = 0;       //Δήλωση πραγματικού αριθμού για το συνολικό κόστος των παραγγελιών
    
    if(pipe(p1) == -1)   //Δημιουργία της πρώτης διοχέτευσης
    {
        perror("Error in pipe1\n");  //Εμφάνιση μηνύματος λάθους σε περίπτωση που δεν δημιουργηθεί η πρώτη διοχέτευση
        return -1;                   //Επιστροφή τιμής -1
    }

    if(pipe(p2) == -1)   //Δημιουργία της δεύτερης διοχέτευσης
    {
        perror("Error in pipe2\n");   //Εμφάνιση μηνύματος λάθους σε περίπτωση που δεν δημιουργηθεί η δεύτερη διοχέτευση
        return -1;                    //Επιστροφή τιμής -1
    }
    
    for(i=0; i<5; i++)       //Επανάληψη 5 φορές για τη δημιουργία 5 θυγατρικών διεργασιών, δηλαδή 5 πελατών
    {
        pid_t pid = fork();     //Δημιουργία νέας διεργασίας με τη χρήση της κλήσης συστήματος fork

        if(pid < 0)         //Ελέγχος για την επιτυχία της δημιουργίας μιας νέας θυγατρικής διεργασίας
        {
            perror("Error in fork\n");   //Εμφάνιση μηνύματος λάθους σε περίπτωση που δεν δημιουργηθεί μια νέα θυγατρική διεργασία
            return -1;
        }

        //Θυγατρική διεργασία
        else if(pid == 0)    //Περίπτωση όπου βρισκόμαστε στην θυγατρική διεργασία
        {                   
            child_orders(p1, p2, i+1);   //Κλήση της συνάρτησης child_orders για την υποβολή των αιτημάτων αγοράς προϊόντων από τον πελάτη
        }                                //i+1 για την μεταφορά του αριθμού του πελάτη στην συνάρτηση child_orders
    }

    parent_orders(catalog, p1, p2, &sum_parag, &sum_succparag, &sum_failparag, &sum_price);   //Κλήση της συνάρτησης parent_orders για την διαχείρηση των υποβληθέντων παραγγελιών από τους πελάτες
                                   //Χρήση δεικτών για την μεταφορά των τιμών των μεταβλητών για χρήση τους στην main συνάρτηση

    for(i=0; i<5; i++)   //Επανάληψη 5 φορές για κάθε θυγατρική διεργασία, πελάτη
    {
        wait(NULL);      //Αναμονή για τον τερματισμό θυγατρικής διεργασίας
    }

    //Συνέχεια αφού οι θυγατρικές διεργασίες έχουν τερματιστεί

    anafora(catalog);   //Κλήση της συνάρτησης anafora για την εξαγωγή συγκεντρωτικής αναφοράς για κάθε προϊόν
    statistics(sum_parag, sum_succparag, sum_failparag, sum_price);  //Κλήση της συνάρτησης statistics για την τύπωση συγκεντρωτικού μηνύματος με τα στατιστικά των παραγγελιών

    return 0;   //Επιστροφή τιμής 0
}